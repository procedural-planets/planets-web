import{S as te,i as ne,s as ae,k as y,q as z,a as k,l as v,m as _,r as A,h as p,c as W,n as h,b as R,G as n,u as V,H as J,J as Z,y as q,z as D,A as O,g as F,d as G,B as M}from"../chunks/index.fe361f2c.js";function ee(d){let e,t,c,f,m,o,r=d[3].text+"",w;return{c(){e=y("div"),t=y("img"),m=k(),o=y("p"),w=z(r),this.h()},l(a){e=v(a,"DIV",{class:!0});var s=_(e);t=v(s,"IMG",{src:!0,alt:!0,class:!0}),m=W(s),o=v(s,"P",{class:!0});var i=_(o);w=A(i,r),i.forEach(p),s.forEach(p),this.h()},h(){Z(t.src,c=d[3].src)||h(t,"src",c),h(t,"alt",f=d[3].desc),h(t,"class","svelte-1wlz5kv"),h(o,"class","svelte-1wlz5kv"),h(e,"class","image svelte-1wlz5kv")},m(a,s){R(a,e,s),n(e,t),n(e,m),n(e,o),n(o,w)},p(a,s){s&8&&!Z(t.src,c=a[3].src)&&h(t,"src",c),s&8&&f!==(f=a[3].desc)&&h(t,"alt",f),s&8&&r!==(r=a[3].text+"")&&V(w,r)},d(a){a&&p(e)}}}function se(d){let e,t,c,f,m,o,r,w,a,s,i=d[3]!=null&&ee(d);return{c(){e=y("div"),t=y("h2"),c=z(d[0]),f=k(),m=y("p"),o=z(d[2]),r=k(),i&&i.c(),w=k(),a=y("p"),s=z(d[1]),this.h()},l(l){e=v(l,"DIV",{class:!0});var u=_(e);t=v(u,"H2",{});var b=_(t);c=A(b,d[0]),b.forEach(p),f=W(u),m=v(u,"P",{class:!0});var H=_(m);o=A(H,d[2]),H.forEach(p),r=W(u),i&&i.l(u),w=W(u),a=v(u,"P",{class:!0});var T=_(a);s=A(T,d[1]),T.forEach(p),u.forEach(p),this.h()},h(){h(m,"class","date svelte-1wlz5kv"),h(a,"class","svelte-1wlz5kv"),h(e,"class","journal-entry svelte-1wlz5kv")},m(l,u){R(l,e,u),n(e,t),n(t,c),n(e,f),n(e,m),n(m,o),n(e,r),i&&i.m(e,null),n(e,w),n(e,a),n(a,s)},p(l,[u]){u&1&&V(c,l[0]),u&4&&V(o,l[2]),l[3]!=null?i?i.p(l,u):(i=ee(l),i.c(),i.m(e,w)):i&&(i.d(1),i=null),u&2&&V(s,l[1])},i:J,o:J,d(l){l&&p(e),i&&i.d()}}}function ie(d,e,t){let{entry_title:c}=e,{entry_text:f}=e,{entry_date:m}=e,{entry_image:o}=e;return d.$$set=r=>{"entry_title"in r&&t(0,c=r.entry_title),"entry_text"in r&&t(1,f=r.entry_text),"entry_date"in r&&t(2,m=r.entry_date),"entry_image"in r&&t(3,o=r.entry_image)},[c,f,m,o]}class N extends te{constructor(e){super(),ne(this,e,ie,se,ae,{entry_title:0,entry_text:1,entry_date:2,entry_image:3})}}function re(d){let e,t,c,f,m,o,r,w,a,s,i,l,u,b,H,T,B,I,j,K,x,L,S;return s=new N({props:{entry_title:"Implementing Worley Noise (Part 1)",entry_date:"2023-05-17",entry_image:{src:"5.png",id:"5",text:"First try at implementing Worley noise. Bottom left corner shows an image of what Worley noise is supposed to look like.",desc:"Procedurally generated planet"},entry_text:`Worley noise is probably the last thing anyone would associate with planetary surfaces. But in our space, everything is possible.

        When creating Worley noise, a few seed points are randomly picked/generated before calculating the distance from every other point to the closest seed point. The noise value for each point corresponds to the distance to the closest seed point. There are different flavours of Worley noise where it does not necessarily have to be the closest seed point.

        Trying to implement this algorithm did not got very well as can be seen in the image. This might be more difficult that what we initially thought.

        To be continued.
        `}}),l=new N({props:{entry_title:"Planet X?",entry_date:"2023-05-16",entry_image:{src:"3.png",id:"3",text:"Procedurally generated planet with a simple shader.",desc:"Procedurally generated planet"},entry_text:`Ahh, an exquisite piece of planetary marvel! Since last time, we have implemented a new type of noise filter and added a simple shader to our planet. 
        
        Mountains in the real world are seldom cone shaped. More often, they are ridge shaped! The new noise filter type is creating this feature by taking the absolute value and inverting the original simplex noise. To make the ridges more distinct, the resulting value is squared. The code was modified to support multiple types of noise filters. This opens up to the possibility of easily adding additional noise filters in the future.

        Next up: shader. We wanted to colour our planet based on the elevation. The first step was finding the highest and lowest point on our planet. The minimum and maximum elevation can be set at the same time that we are evaluating the elevation of each point on our sphere by checking if the elevation of a point is smaller than the minimum or larger than the maxium. The next step is creating the shader. This is easy to do in Unity. The elevation of a pixel on the planet is converted to a value between zero and one based on where it lies between the minimum and maxiumum elevation. The next step was mapping a gradient to these values and boom! Earth 2.0. As we can see in the image, the ocean, which has the lowest elevation, is coloured blue while land is green and mountain tops are snow white.
        
        Up to this point, we have followed Sebastian Lague's tutorial on procedural planets. We have learned a lot about how to use noise to procedurally generate planets. Furthermore, we have gained a lot of experience in working with Unity, which we all had limited experience with before this project. Our next step will be to add another noise filter.
        `}}),b=new N({props:{entry_title:"Make Some Noise!",entry_date:"2023-05-14",entry_image:{src:"2.png",id:"2",text:"Procedurally generated planet using layerd simplex noise.",desc:"Procedurally generated planet"},entry_text:`To change the shape of our sphere to make it into a planet, noise is used to determine the elevation of points on our sphere. The modified version of simplex noise by Sebastian Lague is used in our implementation. Our plan for the future is to implement different types of noise. We have not yet settled on which one, but we have mentioned Worley noise during our group meetings. At this point, we are just following along Lague's tutorial.

        Using a single layer of simplex noise alone to determine the elevation of points on our sphere basically create a blob. We have different parameters that change the characteristics of the terrain such as rougness and strength. Turning up the roughness increases the distance between points which turns the planet into a spike ball. Pretty cool. At this point we can create blobs, spike balls and kinda meteorites - but that's not really what we are here for. We want that planet shape!!

        To turn our blob into a planet the only thing we need to add is a minimum elevation value to our code. This will ensure that no points have a lower elevation than the minimum elevation. With the right settings, the points that are set to this minimum value will create the oceans on our planet and other points will create chunks of land. This can clearly be seens in the image above. We have our planet! Project finished? No.

        One blob high-lone cannot maketh a planet, but two c'rtainly can. That's right Shakespeare! One blob cannot be both farmland and mountains, it can only be one of them. To achieve an authentic look on our planet, we need to layer our noise. This only means creating multiple noise layers. When we want to calculate the elevation of a point, the output from each noise layer is added to the point's elevation.

        Mountains sticking out of the ocean is ruining the immersion. We only want mountains to appear on land! To fix this, we use one of the noise layers as a mask for the other layers. After doing this, we achieve the result in the image above! Done and dusted for this time!
        `}}),T=new N({props:{entry_title:"A Sphere Is Born",entry_date:"2023-05-12",entry_image:{src:"1.png",id:"1",text:"A basic sphere. Note the lines indicating different surface normals.",desc:"sphere"},entry_text:`The first thing that God did when he created the universe was to create spheres. Without spheres, no planets. Without planets, no Earth. Without Earth, no humans. Without humans, no DGI course.

        The first step for us and this project is the same. We want to create a solar system with procedurally generated planets. To create these planets, we need spheres! We base our planets on Sebastian Lague's technique for creating spheres. His YouTube series about the topic has inspried this project and will be used to create a basic planet.

        This technique uses a cube to create a sphere since the size of triangles are the same, resulting in an even distribution of detail. Furthermore, the number of triangles are increased at a reasonable rate when the level of detail is increased. One issue with this technique is that, since the sphere is created from the sides of a cube, surface normals do not match up. This can be seen in the image above. It will however be fixed later in this project.
        
        `}}),{c(){e=y("main"),t=y("div"),c=y("h1"),f=z("Procedural Planets"),m=k(),o=y("p"),r=z("by Albin Kempe, André Fredriksen & Vilhelm Hellmér"),w=k(),a=y("div"),q(s.$$.fragment),i=k(),q(l.$$.fragment),u=k(),q(b.$$.fragment),H=k(),q(T.$$.fragment),B=k(),I=y("footer"),j=y("p"),K=z("KTH DH2323 - "),x=y("a"),L=z("GitHub Repository"),this.h()},l(g){e=v(g,"MAIN",{class:!0});var E=_(e);t=v(E,"DIV",{class:!0});var $=_(t);c=v($,"H1",{});var C=_(c);f=A(C,"Procedural Planets"),C.forEach(p),m=W($),o=v($,"P",{class:!0});var X=_(o);r=A(X,"by Albin Kempe, André Fredriksen & Vilhelm Hellmér"),X.forEach(p),$.forEach(p),w=W(E),a=v(E,"DIV",{class:!0});var P=_(a);D(s.$$.fragment,P),i=W(P),D(l.$$.fragment,P),u=W(P),D(b.$$.fragment,P),H=W(P),D(T.$$.fragment,P),P.forEach(p),B=W(E),I=v(E,"FOOTER",{class:!0});var Y=_(I);j=v(Y,"P",{class:!0});var U=_(j);K=A(U,"KTH DH2323 - "),x=v(U,"A",{href:!0,target:!0,rel:!0,class:!0});var Q=_(x);L=A(Q,"GitHub Repository"),Q.forEach(p),U.forEach(p),Y.forEach(p),E.forEach(p),this.h()},h(){h(o,"class","svelte-16lz6bm"),h(t,"class","title svelte-16lz6bm"),h(a,"class","jorunal"),h(x,"href","https://github.com/procedural-planets/planets-src"),h(x,"target","_blank"),h(x,"rel","noopener noreferrer"),h(x,"class","svelte-16lz6bm"),h(j,"class","svelte-16lz6bm"),h(I,"class","svelte-16lz6bm"),h(e,"class","svelte-16lz6bm")},m(g,E){R(g,e,E),n(e,t),n(t,c),n(c,f),n(t,m),n(t,o),n(o,r),n(e,w),n(e,a),O(s,a,null),n(a,i),O(l,a,null),n(a,u),O(b,a,null),n(a,H),O(T,a,null),n(e,B),n(e,I),n(I,j),n(j,K),n(j,x),n(x,L),S=!0},p:J,i(g){S||(F(s.$$.fragment,g),F(l.$$.fragment,g),F(b.$$.fragment,g),F(T.$$.fragment,g),S=!0)},o(g){G(s.$$.fragment,g),G(l.$$.fragment,g),G(b.$$.fragment,g),G(T.$$.fragment,g),S=!1},d(g){g&&p(e),M(s),M(l),M(b),M(T)}}}class le extends te{constructor(e){super(),ne(this,e,null,re,ae,{})}}export{le as component};
